#!/usr/bin/python
##########################
# Author: A. Malapert
# Version: 0.1
# Licence: GPL
##########################



##########################################
# Import of external classes and functions

import StringIO
import re
import textwrap
import logging
import sys
from sets import Set
import argparse
        

##########################
# Definition of variables         

keys=[];
colsep="|"; 
emptyfield='';

       
##########################
# Definition of functions         

def write_header(ostream, keys, args):
    if not args.noheader : 
        ostream.write("%-20s %s" % ( args.primarykey, args.colsep) )
        for key in keys:
            ostream.write("%-10s %s" % ( key[key.strip().rfind(' ')+1:], args.colsep) )
        ostream.write('\n')

def write_entry(ostream, results, keys,args):
    differences = set(keys).difference(results.keys());
    if len(differences) == len(keys):
        logging.warning("EMPTY Entry %s" % results[args.primarykey])
        return
    elif len(differences) > 0:
        logging.warning("MISSING %s in %s "%  (str(differences), results[args.primarykey]))              
             
    if not args.noheader : ostream.write("%-20s %s" % ( results[args.primarykey], args.colsep))
    for key in keys:
        if results.has_key(key):
            ostream.write("%10s %s" % ( results[key], args.colsep))
        else:
            ostream.write("%10s %s" %  (args.emptyval, args.colsep))
    ostream.write('\n')

def parse_entries(istream, ostream, keys, args):
    results ={} 
    for line in istream:
        ## Search primary key
        match=re.match(args.primarykey, line);
        if match :
            if len(results) > 0: write_entry(ostream, results, keys, args)
            results ={} 
            results[args.primarykey]=line[match.end():].strip();
        ## Search other keys
        for key in keys:
            match=re.match(key, line);
            if match:
                value=line[match.end():].strip();
                if key in results: 
                    logging.debug("%s- replace %s by %s " % ( key, results[key] , value));
                results[key]=value;
    # Flush results
    if len(results) >0: 
        write_entry(ostream, results, keys,args)
        

##########################
# Definition of a main procedure 
if __name__ == "__main__":
    
    # Parse command line
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
%(prog)s produces a table from a set of .o file.
Each line gives information about the resolution of a single problem instance.
Each .o file can contain logs for 0, 1 or n instances.
 '''),
        epilog=textwrap.dedent('''\

%(prog)s 0.1
Copyright (C) 2013 Arnaud Malapert (UNS CNRS).
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.

Written by A Malapert.
''')
        );
    parser.add_argument('-i', '--input', nargs='*',help=".o files of solvers",required=True)
    parser.add_argument('-pk', '--primarykey', default='i ', help="primary key in .o files (entry/line separator)")    
    parser.add_argument('-k', '--keys', type=argparse.FileType('r'), help="text file with prefix searched in .o files") 
    parser.add_argument('-o', '--output', type=argparse.FileType('w'), help="output text file (Table with all results)") 
    parser.add_argument('-c', '--colsep', default='|',help="column separator between fields of the table)") 
    parser.add_argument('-e', '--emptyval',default=' ',help="empty value for a field of the table)") 
    parser.add_argument('-n', '--noheader', action='store_true', help="no row or column header in the table") 
    parser.add_argument('--verbose', action='store_true',help="increase verbosity")
    parser.add_argument('-v','--version', action='version', version='%(prog)s 0.1')
    args=parser.parse_args()

    logging.basicConfig(format='%(levelname)s: %(message)s')

    if not args.input :
        logging.warning("nothing to do");
        exit(0)

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    if args.emptyval == args.colsep :
        logging.warning("column separator and empty field are identical.")

    if args.keys :
        ## read keys from a user file
        for key in args.keys:
            key=key.strip()+' ';
            if len(key)>1 and key not in keys : keys.append(key)
        args.keys.close();
    else : 
        # use default keys
        keys.extend(['s ','o ', 'd NBSOLS ', 'd RUNTIME ','d NODES ', 'd BACKTRACKS '])

    logging.info("KEYS %s" % str(keys)) 
    
    ## Initialize output file
    extre = re.compile('\.[^\.]+$');
    if args.output :
        outfile = args.output
        logging.info("WRITE %s" % outfile.name) 
        if not args.noheader: write_header(outfile,keys, args)
    else :
        outfile=None

    ## Read and extract Table from log files
    for filename in args.input:
        infile=open(filename, 'r')
        if not args.output :
            if outfile : outfile.close();
            fname=extre.sub('.res',filename);
            outfile = open(fname, 'w')
            logging.info("WRITE %s" % outfile.name) 
            if not args.noheader: write_header(outfile,keys, args)
        logging.debug("READ %s" % filename)
        parse_entries(infile,outfile,keys, args)
        infile.close()
    if outfile : outfile.close();

    

    



